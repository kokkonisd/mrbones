#!/usr/bin/env bash


VERSION="0.1.0"
set -e

TEMPLATES_DIR_NAME="_templates"
SITE_DIR_NAME="_site"
VERBOSE=0
WORKING_DIR=$PWD

TEMPLATES_DIR="$WORKING_DIR/$TEMPLATES_DIR_NAME"
SITE_DIR="$WORKING_DIR/$SITE_DIR_NAME"


error_message() {
    echo -e "\e[1m[mrbones]\e[0m  \e[31mERROR: $@\e[0m" 1>&2
}


error() {
    error_message "$@"
    rm -rf $SITE_DIR/
    exit 1
}


info_message() {
    echo -e "\e[1m[mrbones]\e[0m  \e[32m$@\e[0m" 1>&2
}


verbose_message() {
    local message

    if [[ $# -ne 1 ]]
    then
        error "(INTERNAL) incorrect arguments to \`verbose_message(message)\`."
    fi

    if [[ $VERBOSE -ne 1 ]]
    then
        return
    fi

    message=$1

    echo -e "\e[1m[mrbones]\e[0m  \e[38;5;244m$message\e[0m" 1>&2
}


handle_includes() {
    local page page_content include_body

    if [[ $# -ne 1 ]]
    then
        error "(INTERNAL): incorrect arguments to \`handle_includes(src_page_path)\`."
    fi

    src_page_path=$1

    page_content="$(cat $src_page_path)"
    for include in $(sed -nE 's/@include (.+)/\1/p' $src_page_path)
    do
        # Check if include exists.
        if [[ ! -f $TEMPLATES_DIR/$include ]]
        then
            error "$src_page_path: file '$TEMPLATES_DIR/$include' does not exist (missing import.)"
        fi

        # We need to handle includes recursively.
        include_body=$(handle_includes $TEMPLATES_DIR/$include)
        # Replace the `"@include (.+)"` string by the file in the captured group.
        #
        # We need to escape newlines from the template file to be able to feed it to `sed` (i.e.,
        # '\n' -> '\\n'), otherwise it would break up the line and make `sed` think the input is
        # incomplete.
        #
        # However, since `sed` works on a per-line basis, we can't directly replace newlines with
        # their escaped counterpart. So, we do it in two steps: first we use `tr` to transform
        # '\n's to '\\'s, and then we use `sed` to finish the job by transforming '\\'s to '\\n's.
        #
        # Incidentally, we also have to escape '/'s (used in closing HTML tags), as `sed` will
        # mistake them to be separators in the regular expression.
        include_body="$( \
            echo "$include_body" \
            | tr '\n' '\\' \
            | sed --expression='s/\\/\\n/g' \
            | sed --expression='s/\//\\\//g' \
        )"
        page_content="$(sed "s/@include $include/$include_body/g" $src_page_path)"
    done

    echo "$page_content"
}


generate_page() {
    local src_page_path rel_src_page_path dest_page_dir dest_page_path rel_dest_page_path \
        page_content

    if [[ $# -ne 1 ]]
    then
        error "(INTERNAL) incorrect arguments to \`generate_page(src_page_path)\`."
    fi

    src_page_path="$1"
    rel_src_page_path="$(realpath --relative-to=$WORKING_DIR $src_page_path)"
    dest_page_path="$SITE_DIR/$rel_src_page_path"
    verbose_message "  Generating page '$rel_src_page_path'..."

    verbose_message "    Handling includes..."
    page_content="$(handle_includes $src_page_path)"
    verbose_message "    Resolving permalinks..."
    # Handle permalinks.
    #
    # Permalinks are registered via `@permalink <LINK>`. `<LINK>` needs to be an absolute path with
    # regards to the site root (i.e., needs to start with '/'). If there are multiple permalinks,
    # only the last one will be taken into account.
    raw_permalink="$( \
        echo "$page_content" | sed -nE --expression='s/@permalink (.+)/\1/p' | tail -n1 \
    )"
    # Remove any permalink(s) from the file.
    page_content="$(echo "$page_content" | sed -E --expression='/@permalink .+/d')"
    permalink="$raw_permalink"
    # Make sure the permalink is an absolute path (i.e., starts with slash).
    if [[ -n $permalink ]] && [[ $(echo $permalink | cut -b1) != "/" ]]
    then
        error "$src_page_path: permalink must be an absolute path (starting with '/')."
    fi
    # Make sure to normalize the permalink, by ensuring that it ends in ".html"/".htm".
    permalink="$(if [[ -n $permalink ]] && [[ $permalink != *.htm ]] && [[ $permalink != *.html ]]
        then
            echo "$permalink.html"
        else
            echo "$permalink"
        fi)"


    dest_page_path="$(if [[ -n $permalink ]]
        then
            echo "$SITE_DIR/$permalink"
        else
            echo "$dest_page_path"
        fi)"

    # At this point, we still need to check if the permalink escapes the $SITE_DIR.
    # This is a quite obvious vulnerability: if someone uses `/../something` as a permalink, then
    # we will naively generate a file outside $SITE_DIR.
    #
    # In order to check that we are not doing this, we need to use `realpath` to resolve the final
    # path produced by the permalink. However, `realpath` will not work until the path is, well,
    # real.
    #
    # To get around that, we need to first *create the dest directory anyway*, and then test with
    # `realpath`. If it turns out that we have escaped $SITE_DIR, we can roll back that last action
    # by removing the directory we just created.
    #
    # This temporary directory should not be a security issue. Since it is created with `mkdir -p`,
    # it cannot overwrite existing data. At worst, an empty directory will be temporarily created
    # outside $SITE_DIR, and will almost immediately be cleaned up.
    dest_page_dir="$(dirname $dest_page_path)"
    mkdir -p $dest_page_dir/
    # Finally check that the permalink does not escape the $SITE_DIR.
    if [[ -n $permalink ]] && \
        [[ \
            $(realpath -L \
                $SITE_DIR/$(realpath --relative-to=$SITE_DIR $SITE_DIR/$permalink) \
            )/ != $SITE_DIR/* \
        ]]
    then
        # Roll back the temporary directory creation.
        rm -rf $dest_page_dir/
        error "$src_page_path: permalink '$raw_permalink' escapes the generated site directory" \
            "'$SITE_DIR'."
    fi

    rel_dest_page_path="$(realpath --relative-to=$SITE_DIR $dest_page_path)"
    verbose_message "    Putting page in '$SITE_DIR_NAME/$rel_dest_page_path'..."
    echo "$page_content" > "$dest_page_path"
}


parse_arguments() {
    for argument in "$@"
    do
        case $argument in
            "-h" | "--help")
                echo -e "mrbones - a barebones static site generator\n" \
                    "\nusage: mrbones [option(s)]" \
                    "\n  -h, --help     print this help message" \
                    "\n  -v, --verbose  print more verbose messages" \
                    "\n  -V, --version  print this program's version number"
                exit 0
                ;;
            "-v" | "--verbose")
                VERBOSE=1
                ;;
            "-V" | "--version")
                echo "mrbones $VERSION" 1>&2
                exit 0
                ;;
            *)
                WORKING_DIR="$(realpath $argument)"
                TEMPLATES_DIR="$WORKING_DIR/$TEMPLATES_DIR_NAME"
                SITE_DIR="$WORKING_DIR/$SITE_DIR_NAME"
                ;;
        esac

    done
}


main() {
    parse_arguments "$@"

    info_message "Setting up output directory '$SITE_DIR'..."
    verbose_message "  Removing '$SITE_DIR/'..."
    rm -rf "$SITE_DIR"
    verbose_message "  Creating '$SITE_DIR/'..."
    mkdir -p "$SITE_DIR"

    info_message "Generating pages..."
    for src_page in $( \
        find $WORKING_DIR -name "*.html" \
            -not -path "$SITE_DIR/*" \
            -not -path "$TEMPLATES_DIR/*" \
    )
    do
        generate_page "$src_page"
    done

    info_message "Done! Site is ready at '$SITE_DIR'."
}

main "$@"
